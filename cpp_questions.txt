1. Расскажите про new, delete, malloc, free, как они связаны и чем отличаются?

Ответ: *new*, delete - это операторы, а malloc и free - это стандартные библиотечные функции.
Оператор new отличается от функции malloc тем, что new выделяет память и вызывает конструктор,
а malloc только выделяет кусок памяти и возвращает указатель на неё, а инициализировать её
Вы должны сами. Так же оператор delete вызывает деструктор объекта и освобождает память, а
функция free только освобождает память. Функции malloc и free не взаимодействуют с объектами,
не могут инициализировать объект или правильно
его деконструировать.

2. Бывает такое, что оператор new не выделяет память?

Ответ: да, бывает, когда new передаётся указатель на уже выделенную память (например, с
помощью malloc). Это называется placement new. И оператор new без изменения возвращает
второй параметр - указатель (void* operator new(std::size_t, void*)). Это используется
для создания объектов в выделенном "хранилище" или после malloc.

Пример:

#include <iostream>

struct A{
  A(){ std::cout << "I'm constructor\n"; }
  ~A(){ std::cout << "I'm destructor\n"; }
};

int main() {
  void *pv = malloc(sizeof(A)); // или char *pv = new char[sizeof(A)];
  A *pa = new(pv) A;
  std::cout << std::hex << reinterpret_cast<A*>(pv) << " = " << pa << '\n';
  pa->~A();
  free(pv);                     // или delete[] pv;
  pv = nullptr;
}


Важно! В этом случае деструктор нужно вызывать самостоятельно!

3. Отличия между оператором delete, delete[].
Первый выполняет единичный вызов деструктора, а второй оператор - вызывает деструктор
для каждого элемента массива.

4. Что такое инкапсуляция, наследование, полиморфизм?

   Инкапсуляция - это скрытие внутренней реализации от других компонентов (например,
   использование get-, set- методов).

   Наследование - главное преимущество ООП. Выведенный класс (наследник) может наследовать
   свойства, методы и интерфейс другого класса, который называют базовым, а так же добавлять
   свои черты, характерные только для него.
   
   Полиморфизм (шаблоны - статический полиморфизм, виртуальные функции, перегрузка функций
   и операторов - динамический полиморфизм) - повторное использование кода, одно и тоже имя
   класса или функции для единого класса действий. Вызов конкретной версии функции зависит
   от объекта, который передают в качества параметра.

5. Порядок вызова конструкторов и деструкторов базового и производного классов при создании
и удалении объекта.

Сначала вызывается конструктор базового класса, затем производного. При удалении вызывается
деструктор производного класса, а затем базового.
При наличии членов класса порядок вызовов такой: конструкторы членов базового класса,
конструктор базового класса, конструкторы членов производного класса, конструктор производного
класса. При удалении порядок обратный: деструктор производного класса, деструкторы членов
производного класса, деструктор базового класса, деструкторы членов базового класса.  

Пример:

#include <iostream>

class Member1{
public:
  Member1(){ std::cout << "Member1 constructor\n"; }
  ~Member1(){ std::cout << "Member1 destructor\n"; }
};

class Member2{
public:
  Member2(){ std::cout << "Member2 constructor\n"; }
  ~Member2(){ std::cout << "Member2 destructor\n"; }
};

class Base{
  Member1 m1;
  Member2 m2;
public:
  Base(){ std::cout << "Base constructor\n"; }
  ~Base(){ std::cout << "Base destructor\n"; }
};

class Member3{
public:
  Member3(){ std::cout << "Member3 constructor\n"; }
  ~Member3(){ std::cout << "Member3 destructor\n"; }
};

class Member4{
public:
  Member4(){ std::cout << "Member4 constructor\n"; }
  ~Member4(){ std::cout << "Member4 destructor\n"; }
};

class Child : public Base{
  Member3 m3;
  Member4 m4;
  
public:
  Child(){ std::cout << "Child constructor\n"; }
  ~Child(){ std::cout << "Child destructor\n"; }
};


int main() {
  Child ch;
}

Вывод:
Member1 constructor
Member2 constructor
Base constructor
Member3 constructor
Member4 constructor
Child constructor
Child destructor
Member4 destructor
Member3 destructor
Base destructor
Member2 destructor
Member1 destructor

6. Что такое виртуальные функции? Что такое чисто виртуальные функции и чисто
виртуальный деструктор? Что такое абстрактный класс?

Ответ: Виртуальная функция - это функция, объявление которой содержит ключевое слово
virtual. Если функция объявлена виртуальной в базовом классе, то она становится
виртуальной и в производных классах и там писать слово virtual избыточно. Тело это
функции может быть переопределено в производном классе. Для безошибочного переопределения
виртуальной функции лучше добавлять ключевое слово override.

При вызове виртуальной функции происходит динамическое или позднее связывание компилятор
вставляет в программу фрагмент кода для определения  и вызова правильной функции,
зависящей от типа объекта.

Как работает механизм определения типа объекта: компилятор создает таблицу VTABLE
виртуальных функций для каждого класса, содержащего виртуальные функции. И помещает
туда адреса виртуальных функций данного класса. В каждом таком классе скрыто хранится
указатель на таблицу виртуальных функций VPTR.
При вызове виртуальной функции через указатель на базовый класс, компилятор вставляет
в программу код, который получает указатель VPTR и добавляет смещение для нужной функции. 

Чисто виртуальная функция - это функция, тело которой отсутствует и = 0; Её необходимо
определить в производном классе.

Пример: virtual void draw() = 0;

Абстрактный класс - это класс, содержащий хотя бы одну чисто виртуальную функцию.
Создать объект такого класса невозможно. Он нужен только для того, чтобы унаследовать его
интерфейс.

7. Может ли конструктор и деструктор быть виртуальными?

Виртуальных конструкторов не бывает. Возможна имитация виртуального конструктора с помощью
паттерна "Фабрики объектов".
Виртуальный деструктор необходим, когда в нём есть хоть одна виртуальная функция или класс
является базовым. При удалении объекта производного класса через указатель на базовый класс,
деструктор которого не является виртуальным, результат не определен. Чаще всего результатом
будет утечка памяти, так как не вызовется деструктор производного класса.

Пример:
#include <iostream>

class A{
public:
  A(){ std::cout << "A constructor\n"; }
  ~A(){ std::cout << "A destructor\n"; }
};
class B : public A{
public:
  B(){ std::cout << "B constructor\n"; }
  ~B(){ std::cout << "B destructor\n"; }
};


int main() {
  A *pb = new B;
  delete pb;
}

Вывод:
A constructor
B constructor
              <------ здесь должен быть вызов деструктора класса B
A destructor


8. Какое значение будет выведено на экран:

#include <iostream>

int f(int x){
  int count = 0;
  while(x){
    count++;
    x = x&(x-1);
  }
  return count;
}

int main() {
  std::cout << f(9999) << std::endl;
}

Ответ: 8, выведется количество не нулевых битов числа, передаваемого в качестве
параметра в функцию f.

9. Что такое ссылка? Как можно инициализировать ссылку одной или другой переменной в
зависимости от условия? 

Ответ: это другое имя для переменной. Ссылку необходимо инициализировать при объявлении
и изменять уже нельзя. С помощью тернарного оператора или с помощью лямбда-функции.

Пример №1:

  int a = 10;
  int b = 20;
  int &c = a > 10 ? a : b;
  
Пример №2:

  int a = 10;
  int b = 20;
  auto lm = [&a, &b]() -> int& { return a > 10 ? a : b; };
  int& d = lm();

10. В чем отличие структуры и объединения?

Ответ: в структуре все её члены хранятся одновременно, и к ним есть доступ. В объединении
существует только один тип, который в данный момент используется. Доступ к остальным
вызовет неопределенное поведение (undefined behavior).

11. Может ли шаблонная функция быть виртуальной?

Ответ: шаблонная функция не может быть виртуальной, потому что это слишком большое
усложнение устройства таблицы виртуальных функций. Шаблонные функции генерируются на
этапе компиляции (статическое связывание), а объявление функции виртуальной означает,
что компилятор должен выполнить позднее связывание (динамическое) и на этапе выполнения
вызовется «нужная функция» для каждого класса через указатель на таблицу виртуальных
функций плюс смещение. Эта таблица должна быть фиксированного размера и содержать
только одну запись для виртуальной функции, а в случае шаблонной виртуальной функции
их будет несколько и их количество не будет известно до трансляции всей программы.

12. Бывает ли специализация шаблона? Что такое частичная специализация?

Ответ: да, шаблон класса или функции можно специализировать, то есть указать реализацию
для конкретных аргументов. А частичная специализация означает, что параметров у шаблона
несколько и для одного или нескольких указываются конкретные аргументы, или,
возможно, указывается, что параметры имеют один и тот же тип.

Это шаблон:
template<typename T1, typename T2>
class A{
…
};

// Частичная специализация (указан конкретный аргумент double):
template<typename T1>
class A<T1, double>{
…
};

// Частичная специализация (указано, что параметры имеют один и тот же тип):
template <typename T>
class A<T, T> {
…
};

